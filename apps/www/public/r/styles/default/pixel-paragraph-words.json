{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixel-paragraph-words",
  "description": "Paragraph where specific words render in an interactive pixel font that swaps or cycles on hover",
  "dependencies": [
    "geist"
  ],
  "files": [
    {
      "path": "registry/default/ui/pixel-paragraph-words.tsx",
      "content": "/**\n * @module PixelParagraph\n *\n * Renders a paragraph where specific words / phrases use a pixel font\n * while the rest of the text stays in the normal font.\n *\n * Setup â€” Geist Pixel Fonts with Tailwind CSS\n * =============================================\n *\n * All Geist fonts can be used through CSS variables:\n *\n *   GeistSans:          --font-geist-sans\n *   GeistMono:          --font-geist-mono\n *   GeistPixelSquare:   --font-geist-pixel-square\n *   GeistPixelGrid:     --font-geist-pixel-grid\n *   GeistPixelCircle:   --font-geist-pixel-circle\n *   GeistPixelTriangle: --font-geist-pixel-triangle\n *   GeistPixelLine:     --font-geist-pixel-line\n *\n * 1. Register the font variables in app/layout.js:\n *\n *   ```js\n *   import { GeistSans } from \"geist/font/sans\";\n *   import { GeistMono } from \"geist/font/mono\";\n *   import { GeistPixelSquare } from \"geist/font/pixel\";\n *\n *   export default function RootLayout({ children }) {\n *     return (\n *       <html\n *         lang=\"en\"\n *         className={`${GeistSans.variable} ${GeistMono.variable} ${GeistPixelSquare.variable}`}\n *       >\n *         <body>{children}</body>\n *       </html>\n *     );\n *   }\n *   ```\n *\n * 2. Map the CSS variables in your Tailwind CSS v4 theme (tailwind.css):\n *\n *   ```css\n *   @theme {\n *     --font-sans: var(--font-geist-sans);\n *     --font-mono: var(--font-geist-mono);\n *     --font-pixel-square: var(--font-geist-pixel-square);\n *     --font-pixel-grid: var(--font-geist-pixel-grid);\n *     --font-pixel-circle: var(--font-geist-pixel-circle);\n *     --font-pixel-triangle: var(--font-geist-pixel-triangle);\n *     --font-pixel-line: var(--font-geist-pixel-line);\n *   }\n *   ```\n *\n * Once configured, the `font-pixel-*` utility classes used by this\n * component will resolve correctly.\n *\n * @example\n * <PixelParagraph\n *   text=\"54+ animated components and effects. Free, open source, and built to drop into any shadcn/ui project.\"\n *   pixelWords={[\"animated\", \"shadcn/ui\"]}\n *   font=\"square\"\n *   className=\"text-lg text-muted-foreground\"\n * />\n */\n\nimport { cn } from \"@/lib/utils\";\n\n/* ------------------------------------------------------------------ */\n/* Pixel-font constants                                                */\n/* ------------------------------------------------------------------ */\n\ntype PixelFont = \"square\" | \"grid\" | \"circle\" | \"triangle\" | \"line\";\n\nconst PIXEL_FONT_MAP: Record<PixelFont, string> = {\n\tsquare: \"font-pixel-square\",\n\tgrid: \"font-pixel-grid\",\n\tcircle: \"font-pixel-circle\",\n\ttriangle: \"font-pixel-triangle\",\n\tline: \"font-pixel-line\",\n};\n\n/* ------------------------------------------------------------------ */\n/* Text-splitting helper                                               */\n/* ------------------------------------------------------------------ */\n\ntype Segment =\n\t| { type: \"plain\"; text: string }\n\t| { type: \"pixel\"; text: string };\n\n/**\n * Splits `text` into alternating plain / pixel segments based on the\n * provided `pixelWords`.  Longer phrases are matched first so that\n * \"shadcn/ui\" wins over a hypothetical \"ui\" match.\n */\nfunction splitTextByPixelWords(\n\ttext: string,\n\tpixelWords: string[],\n): Segment[] {\n\tif (pixelWords.length === 0) return [{ type: \"plain\", text }];\n\n\t// Sort by length descending so longer matches take priority\n\tconst sorted = [...pixelWords].sort((a, b) => b.length - a.length);\n\n\t// Escape regex-special characters in each word\n\tconst escaped = sorted.map((w) =>\n\t\tw.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"),\n\t);\n\n\tconst pattern = new RegExp(`(${escaped.join(\"|\")})`, \"g\");\n\n\tconst segments: Segment[] = [];\n\tlet lastIndex = 0;\n\n\tfor (const match of text.matchAll(pattern)) {\n\t\tconst matchStart = match.index ?? 0;\n\t\tif (matchStart > lastIndex) {\n\t\t\tsegments.push({ type: \"plain\", text: text.slice(lastIndex, matchStart) });\n\t\t}\n\t\tsegments.push({ type: \"pixel\", text: match[0] });\n\t\tlastIndex = matchStart + match[0].length;\n\t}\n\n\tif (lastIndex < text.length) {\n\t\tsegments.push({ type: \"plain\", text: text.slice(lastIndex) });\n\t}\n\n\treturn segments;\n}\n\n/* ------------------------------------------------------------------ */\n/* PixelParagraph                                                      */\n/* ------------------------------------------------------------------ */\n\nexport interface PixelParagraphProps extends React.ComponentProps<\"p\"> {\n\t/** The paragraph text to render. */\n\ttext: string;\n\t/**\n\t * Words or phrases within `text` to render in a pixel font.\n\t * Matching is case-sensitive and longest-match-first.\n\t */\n\tpixelWords?: string[];\n\t/** The wrapper element to render. @default \"p\" */\n\tas?: \"p\" | \"span\" | \"div\";\n\t/** The pixel font for highlighted words. @default \"square\" */\n\tfont?: PixelFont;\n\t/** Extra className applied to each pixel-word span. */\n\tpixelWordClassName?: string;\n}\n\n/**\n * Paragraph that renders specific words / phrases in a pixel font\n * while the rest stays in the normal typeface.\n *\n * @example\n * <PixelParagraph\n *   text=\"54+ animated components and effects. Free, open source, and built to drop into any shadcn/ui project.\"\n *   pixelWords={[\"animated\", \"shadcn/ui\"]}\n *   font=\"square\"\n *   className=\"text-lg text-muted-foreground\"\n * />\n */\nexport function PixelParagraph({\n\ttext,\n\tpixelWords = [],\n\tas: Tag = \"p\",\n\tclassName,\n\tfont = \"square\",\n\tpixelWordClassName,\n\t...props\n}: PixelParagraphProps) {\n\tconst segments = splitTextByPixelWords(text, pixelWords);\n\tconst fontClass = PIXEL_FONT_MAP[font];\n\n\treturn (\n\t\t<Tag data-slot=\"pixel-paragraph\" className={cn(className)} {...props}>\n\t\t\t{segments.map((segment, index) => {\n\t\t\t\tconst key = `${segment.type}-${segment.text}-${index}`;\n\t\t\t\treturn segment.type === \"pixel\" ? (\n\t\t\t\t\t<span\n\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\tdata-slot=\"pixel-word\"\n\t\t\t\t\t\tclassName={cn(fontClass, pixelWordClassName)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{segment.text}\n\t\t\t\t\t</span>\n\t\t\t\t) : (\n\t\t\t\t\t<span key={key}>{segment.text}</span>\n\t\t\t\t);\n\t\t\t})}\n\t\t</Tag>\n\t);\n}\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}