{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixel-paragraph-words-inverse",
  "description": "Paragraph in pixel font where specific words escape into interactive sans/mono with hover swap or cycle",
  "dependencies": [
    "geist"
  ],
  "files": [
    {
      "path": "registry/default/ui/pixel-paragraph-words-inverse.tsx",
      "content": "/**\n * @module PixelParagraphInverse\n *\n * Renders a paragraph where the base text is in a pixel font and\n * specific words / phrases escape into sans or mono.\n *\n * This is the inverse of `PixelParagraph`: instead of highlighting\n * words *in* pixel, everything is pixel *except* the specified words.\n *\n * Setup â€” Geist Pixel Fonts with Tailwind CSS\n * =============================================\n *\n * All Geist fonts can be used through CSS variables:\n *\n *   GeistSans:          --font-geist-sans\n *   GeistMono:          --font-geist-mono\n *   GeistPixelSquare:   --font-geist-pixel-square\n *   GeistPixelGrid:     --font-geist-pixel-grid\n *   GeistPixelCircle:   --font-geist-pixel-circle\n *   GeistPixelTriangle: --font-geist-pixel-triangle\n *   GeistPixelLine:     --font-geist-pixel-line\n *\n * 1. Register the font variables in app/layout.js:\n *\n *   ```js\n *   import { GeistSans } from \"geist/font/sans\";\n *   import { GeistMono } from \"geist/font/mono\";\n *   import { GeistPixelSquare } from \"geist/font/pixel\";\n *\n *   export default function RootLayout({ children }) {\n *     return (\n *       <html\n *         lang=\"en\"\n *         className={`${GeistSans.variable} ${GeistMono.variable} ${GeistPixelSquare.variable}`}\n *       >\n *         <body>{children}</body>\n *       </html>\n *     );\n *   }\n *   ```\n *\n * 2. Map the CSS variables in your Tailwind CSS v4 theme (tailwind.css):\n *\n *   ```css\n *   @theme {\n *     --font-sans: var(--font-geist-sans);\n *     --font-mono: var(--font-geist-mono);\n *     --font-pixel-square: var(--font-geist-pixel-square);\n *     --font-pixel-grid: var(--font-geist-pixel-grid);\n *     --font-pixel-circle: var(--font-geist-pixel-circle);\n *     --font-pixel-triangle: var(--font-geist-pixel-triangle);\n *     --font-pixel-line: var(--font-geist-pixel-line);\n *   }\n *   ```\n *\n * Once configured, the `font-pixel-*` and `font-sans` / `font-mono`\n * utility classes used by this component will resolve correctly.\n *\n * @example\n * <PixelParagraphInverse\n *   text=\"54+ animated components and effects. Free, open source, and built to drop into any shadcn/ui project.\"\n *   plainWords={[\"animated\", \"shadcn/ui\"]}\n *   plainFont=\"sans\"\n *   pixelFont=\"square\"\n *   className=\"text-lg text-muted-foreground\"\n * />\n */\n\nimport { cn } from \"@/lib/utils\";\n\n/* ------------------------------------------------------------------ */\n/* Font constants                                                      */\n/* ------------------------------------------------------------------ */\n\ntype PlainFont = \"sans\" | \"mono\";\ntype PixelFont = \"square\" | \"grid\" | \"circle\" | \"triangle\" | \"line\";\n\nconst PLAIN_FONT_MAP: Record<PlainFont, string> = {\n\tsans: \"font-sans\",\n\tmono: \"font-mono\",\n};\n\nconst PIXEL_FONT_MAP: Record<PixelFont, string> = {\n\tsquare: \"font-pixel-square\",\n\tgrid: \"font-pixel-grid\",\n\tcircle: \"font-pixel-circle\",\n\ttriangle: \"font-pixel-triangle\",\n\tline: \"font-pixel-line\",\n};\n\n/* ------------------------------------------------------------------ */\n/* Text-splitting helper                                               */\n/* ------------------------------------------------------------------ */\n\ntype Segment =\n\t| { type: \"pixel\"; text: string }\n\t| { type: \"plain\"; text: string };\n\n/**\n * Splits `text` into alternating pixel / plain segments based on the\n * provided `plainWords`.  Longer phrases are matched first so that\n * \"shadcn/ui\" wins over a hypothetical \"ui\" match.\n */\nfunction splitTextByPlainWords(\n\ttext: string,\n\tplainWords: string[],\n): Segment[] {\n\tif (plainWords.length === 0) return [{ type: \"pixel\", text }];\n\n\t// Sort by length descending so longer matches take priority\n\tconst sorted = [...plainWords].sort((a, b) => b.length - a.length);\n\n\t// Escape regex-special characters in each word\n\tconst escaped = sorted.map((w) =>\n\t\tw.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"),\n\t);\n\n\tconst pattern = new RegExp(`(${escaped.join(\"|\")})`, \"g\");\n\n\tconst segments: Segment[] = [];\n\tlet lastIndex = 0;\n\n\tfor (const match of text.matchAll(pattern)) {\n\t\tconst matchStart = match.index ?? 0;\n\t\tif (matchStart > lastIndex) {\n\t\t\tsegments.push({ type: \"pixel\", text: text.slice(lastIndex, matchStart) });\n\t\t}\n\t\tsegments.push({ type: \"plain\", text: match[0] });\n\t\tlastIndex = matchStart + match[0].length;\n\t}\n\n\tif (lastIndex < text.length) {\n\t\tsegments.push({ type: \"pixel\", text: text.slice(lastIndex) });\n\t}\n\n\treturn segments;\n}\n\n/* ------------------------------------------------------------------ */\n/* PixelParagraphInverse                                               */\n/* ------------------------------------------------------------------ */\n\nexport interface PixelParagraphInverseProps extends React.ComponentProps<\"p\"> {\n\t/** The paragraph text to render. */\n\ttext: string;\n\t/**\n\t * Words or phrases within `text` to render in a plain (sans/mono) font.\n\t * Everything else renders in the pixel font.\n\t * Matching is case-sensitive and longest-match-first.\n\t */\n\tplainWords?: string[];\n\t/** The wrapper element to render. @default \"p\" */\n\tas?: \"p\" | \"span\" | \"div\";\n\t/** The pixel font used for the base text. @default \"square\" */\n\tpixelFont?: PixelFont;\n\t/** The plain font for highlighted words. @default \"sans\" */\n\tplainFont?: PlainFont;\n\t/** Extra className applied to each plain-word span. */\n\tplainWordClassName?: string;\n}\n\n/**\n * Paragraph where the base text is in a pixel font and specific words\n * or phrases escape into a sans or mono font.\n *\n * @example\n * <PixelParagraphInverse\n *   text=\"54+ animated components and effects. Free, open source, and built to drop into any shadcn/ui project.\"\n *   plainWords={[\"animated\", \"shadcn/ui\"]}\n *   plainFont=\"sans\"\n *   pixelFont=\"square\"\n *   className=\"text-lg text-muted-foreground\"\n * />\n */\nexport function PixelParagraphInverse({\n\ttext,\n\tplainWords = [],\n\tas: Tag = \"p\",\n\tclassName,\n\tpixelFont = \"square\",\n\tplainFont = \"sans\",\n\tplainWordClassName,\n\t...props\n}: PixelParagraphInverseProps) {\n\tconst segments = splitTextByPlainWords(text, plainWords);\n\tconst pixelFontClass = PIXEL_FONT_MAP[pixelFont];\n\tconst plainFontClass = PLAIN_FONT_MAP[plainFont];\n\n\treturn (\n\t\t<Tag\n\t\t\tdata-slot=\"pixel-paragraph-inverse\"\n\t\t\tclassName={cn(pixelFontClass, className)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{segments.map((segment, index) => {\n\t\t\t\tconst key = `${segment.type}-${segment.text}-${index}`;\n\t\t\t\treturn segment.type === \"plain\" ? (\n\t\t\t\t\t<span\n\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\tdata-slot=\"plain-word\"\n\t\t\t\t\t\tclassName={cn(plainFontClass, plainWordClassName)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{segment.text}\n\t\t\t\t\t</span>\n\t\t\t\t) : (\n\t\t\t\t\t<span key={key}>{segment.text}</span>\n\t\t\t\t);\n\t\t\t})}\n\t\t</Tag>\n\t);\n}\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}